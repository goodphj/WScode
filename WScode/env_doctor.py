import os
import sys
import subprocess
import json
import shutil
import re

# Configuration
REQUIRED_DIRS = ["generated", "custom", "source", "board", "sdk"]
VSCODE_DIR = ".vscode"
CPP_PROPS_FILE = "c_cpp_properties.json"

def print_status(msg, status):
    symbol = "‚úÖ" if status else "‚ùå"
    print(f"{symbol} {msg}")

def check_structure():
    print("\n[1] Checking Directory Structure...")
    cwd = os.getcwd()
    print(f"Current Root: {cwd}")
    
    missing = []
    
    # Check for CMakeLists.txt (The Blueprint)
    if not os.path.exists(os.path.join(cwd, "CMakeLists.txt")):
        print_status("Missing file: CMakeLists.txt", False)
        print("   -> üõë CRITICAL: 'CMakeLists.txt' is missing.")
        print("      This file is required to generate the build folder (flash_debug).")
        return False

    for d in REQUIRED_DIRS:
        if not os.path.exists(os.path.join(cwd, d)):
            missing.append(d)
    
    if missing:
        print_status(f"Missing directories: {', '.join(missing)}", False)
        
        # Check parent directory for hints
        parent_dir = os.path.dirname(cwd)
        if all(os.path.exists(os.path.join(parent_dir, d)) for d in missing):
            print(f"   -> üí° Hint: Found these directories in '{parent_dir}'.")
            print("      You might be running this script inside a subfolder.")
            
        # Check for simulator confusion
        if "source" in missing:
            sim_main = os.path.join(cwd, "lvgl-simulator", "main.c")
            if os.path.exists(sim_main):
                print("   -> ‚ÑπÔ∏è  Clarification: Found 'lvgl-simulator/main.c'.")
                print("      This file is for PC Simulation (SDL2) and cannot be compiled")
                print("      for the i.MX RT700 embedded target (requires 'source/main.c').")

        print("   -> üõë CRITICAL: Core source directories are missing.")
        print("      The build WILL FAIL without the target main.c.")
        return False
    
    print_status("All required directories found.", True)
    return True

def repair_structure():
    print("\n[!] Attempting to repair project structure...")
    
    # Create missing directories
    for d in REQUIRED_DIRS:
        if not os.path.exists(d):
            os.makedirs(d)
            print(f"   Created directory: {d}")

    # Check if a main() already exists to avoid creating a duplicate
    cwd = os.getcwd()
    main_pattern = re.compile(r'^\s*(int|void)\s+main\s*\(', re.MULTILINE)
    existing_main = False
    
    for root, dirs, files in os.walk(cwd):
        if any(x in root for x in ["build", "Debug", "Release", ".git", ".vscode", "lvgl-simulator", "ports"]):
            continue
        for file in files:
            if file.endswith((".c", ".cpp")):
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        if main_pattern.search(content) and "__attribute__((weak))" not in content:
                            if "Generated by env_doctor.py" in content:
                                continue
                            existing_main = True
                            print(f"   ‚ÑπÔ∏è  Found existing main in: {os.path.relpath(path, cwd)}")
                            break
                except: pass
        if existing_main: break

    # Create skeleton source/main.c ONLY if no existing main found
    main_c = os.path.join("source", "main.c")
    if not os.path.exists(main_c):
        if not existing_main:
            with open(main_c, "w") as f:
                f.write("/* Generated by env_doctor.py */\n")
                f.write("#include <stdio.h>\n")
                f.write("#include \"board.h\"\n")
                f.write("int main(void) {\n")
                f.write("    BOARD_Init();\n")
                f.write("    /* TODO: Call App_CreateGuiTask() here. See Guide.md */\n")
                f.write("    printf(\"Hello World from env_doctor\\n\");\n")
                f.write("    while(1);\n")
                f.write("    return 0;\n")
                f.write("}\n")
            print_status("Created skeleton source/main.c", True)
        else:
            print("   ‚ÑπÔ∏è  Skipping skeleton creation (Main already exists).")

    # Create skeleton board/board.h
    board_h = os.path.join("board", "board.h")
    if not os.path.exists(board_h):
        with open(board_h, "w") as f:
            f.write("#ifndef _BOARD_H_\n#define _BOARD_H_\nvoid BOARD_Init(void);\n#endif\n")
        print_status("Created skeleton board/board.h", True)

def get_compiler_path():
    # 1. Check PATH
    try:
        subprocess.run(["arm-none-eabi-gcc", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return "arm-none-eabi-gcc"
    except FileNotFoundError:
        pass

    # 2. Check standard NXP installation paths
    nxp_root = r"C:\NXP"
    if os.path.exists(nxp_root):
        for item in os.listdir(nxp_root):
            if item.startswith("MCUXpressoIDE"):
                # Typical path: C:\NXP\MCUXpressoIDE_25.6.136\ide\tools\bin\arm-none-eabi-gcc.exe
                candidate = os.path.join(nxp_root, item, "ide", "tools", "bin", "arm-none-eabi-gcc.exe")
                if os.path.exists(candidate):
                    return candidate
    return None

def check_compiler():
    print("\n[2] Checking Toolchain...")

    # Check CMake
    try:
        subprocess.run(["cmake", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print_status("Found: cmake", True)
    except FileNotFoundError:
        print_status("Not found in PATH: cmake", False)
    
    # Check Ninja (usually in PATH)
    try:
        subprocess.run(["ninja", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print_status("Found: ninja", True)
    except FileNotFoundError:
        print_status("Not found in PATH: ninja", False)

    # Check GCC
    compiler_path = get_compiler_path()
    if compiler_path:
        print_status(f"Found compiler: {compiler_path}", True)
        return compiler_path
    else:
        print_status("arm-none-eabi-gcc not found in PATH or C:\\NXP\\...", False)
        return None

def update_vscode_config(compiler_path):
    print("\n[3] Updating VS Code Configuration...")
    if not os.path.exists(VSCODE_DIR):
        os.makedirs(VSCODE_DIR)
        print(f"   Created {VSCODE_DIR} directory.")

    config_path = os.path.join(VSCODE_DIR, CPP_PROPS_FILE)
    
    # Define include paths dynamically based on current location
    include_paths = [
        "${workspaceFolder}/**",
        "${workspaceFolder}/generated",
        "${workspaceFolder}/custom",
        "${workspaceFolder}/source",
        "${workspaceFolder}/board",
        "${workspaceFolder}/sdk"
    ]

    config_data = {
        "configurations": [
            {
                "name": "NXP i.MX RT700",
                "includePath": include_paths,
                "compileCommands": "${workspaceFolder}/sdk/vscode/flash_debug/compile_commands.json",
                "defines": [
                    "CPU_MIMXRT798SGFOA",
                    "CPU_MIMXRT798SGFOA_cm33",
                    "CPU_MIMXRT798SGFOA_cm33_core0",
                    "MCUXPRESSO_SDK",
                    "SDK_DEBUGCONSOLE=1",
                    "MCUX_META_BUILD",
                    "MIMXRT798S_cm33_core0_SERIES",
                    "BOOT_HEADER_ENABLE=1",
                    "LV_CONF_INCLUDE_SIMPLE=1",
                    "SDK_OS_FREE_RTOS",
                    "__MCUXPRESSO",
                    "__USE_CMSIS",
                    "DEBUG",
                    "__NEWLIB__"
                ],
                "forcedInclude": [
                    "${workspaceFolder}/source/mcux_config.h"
                ],
                "compilerPath": compiler_path if compiler_path else "arm-none-eabi-gcc",
                "cStandard": "c99",
                "cppStandard": "c++11",
                "intelliSenseMode": "gcc-arm"
            }
        ],
        "version": 4
    }

    try:
        with open(config_path, 'w') as f:
            json.dump(config_data, f, indent=4)
        print_status(f"Updated {CPP_PROPS_FILE} with correct paths.", True)
    except Exception as e:
        print_status(f"Failed to write config: {e}", False)

def check_and_clean_cache():
    print("\n[4] Checking CMake Cache Consistency...")
    cwd = os.getcwd()
    
    potential_build_dirs = [
        "build", "cmake-build-debug", "Debug", "Release",
        os.path.join("sdk", "vscode", "flash_debug"),
        os.path.join("sdk", "vscode", "flash_release")
    ]
    
    stale_found = False
    
    for d in potential_build_dirs:
        full_path = os.path.join(cwd, d)
        cache_file = os.path.join(full_path, "CMakeCache.txt")
        
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r', errors='ignore') as f:
                    content = f.read()
                    # Check if CMAKE_HOME_DIRECTORY matches current cwd
                    if f"CMAKE_HOME_DIRECTORY:INTERNAL={cwd.replace(os.sep, '/')}" not in content and \
                       f"CMAKE_HOME_DIRECTORY:INTERNAL={cwd}" not in content:
                        print(f"‚ö†Ô∏è  Stale Cache detected in '{d}' (Wrong Root Path)")
                        print(f"   -> Deleting '{d}' to force reconfiguration...")
                        shutil.rmtree(full_path)
                        stale_found = True
            except Exception:
                pass

    if not stale_found:
        print_status("Build cache is clean or not found.", True)

def check_entry_point():
    print("\n[5] Scanning for 'main()' definitions...")
    cwd = os.getcwd()
    # Regex to find 'int main(' or 'void main(' at start of line or after whitespace
    main_pattern = re.compile(r'^\s*(int|void)\s+main\s*\(', re.MULTILINE)
    
    found_mains = []
    
    for root, dirs, files in os.walk(cwd):
        # Skip build and hidden directories to save time
        if any(x in root for x in ["build", "Debug", "Release", ".git", ".vscode"]):
            continue
            
        for file in files:
            if file.endswith((".c", ".cpp")):
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        if main_pattern.search(content):
                            rel_path = os.path.relpath(path, cwd)
                            is_weak = "__attribute__((weak))" in content
                            found_mains.append((rel_path, is_weak))
                except Exception:
                    pass

    if not found_mains:
        print("   -> ‚ùå No 'main()' function found in the project.")
        return
        
    user_mains = []
    final_main = None
    for path, is_weak in found_mains:
        if "lvgl-simulator" in path or "ports" in path:
            print(f"   - {path}: ‚ÑπÔ∏è  Simulator/Port (Ignored for Target)")
        elif "startup" in path or is_weak:
             print(f"   - {path}: ‚ö†Ô∏è  Startup/Weak (System Boot Code)")
        else:
             print(f"   - {path}: ‚úÖ  User Application Entry")
             user_mains.append(path)
    
    if len(user_mains) == 1:
        final_main = user_mains[0]

    # Auto-resolve conflict if one is the skeleton file
    if len(user_mains) > 1:
        print("\n   ‚ö†Ô∏è  Conflict: Multiple User Application Entries found.")
        skeleton_to_remove = None
        for m in user_mains:
             full_path = os.path.join(cwd, m)
             try:
                 with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                     if "Generated by env_doctor.py" in f.read():
                         skeleton_to_remove = full_path
                         break
             except: pass
        
        if skeleton_to_remove:
             try:
                 os.remove(skeleton_to_remove)
                 print(f"   -> Auto-removing skeleton file: {os.path.relpath(skeleton_to_remove, cwd)}")
                 print_status(f"Removed {os.path.relpath(skeleton_to_remove, cwd)} to use existing main.", True)
                 
                 # Update final_main to the survivor
                 rel_skel = os.path.relpath(skeleton_to_remove, cwd)
                 for m in user_mains:
                     if m != rel_skel:
                         final_main = m
                         break
             except Exception as e:
                 print(f"   -> Failed to remove skeleton: {e}")
    
    return final_main

def repair_cmake_mismatch(target_main):
    print("\n[!] Attempting to repair CMakeLists.txt...")
    cwd = os.getcwd()
    cmake_path = os.path.join(cwd, "CMakeLists.txt")
    
    # Backup existing
    if os.path.exists(cmake_path):
        backup_path = os.path.join(cwd, "CMakeLists.txt.simulator")
        shutil.copy2(cmake_path, backup_path)
        print(f"   -> Backed up current config to '{os.path.basename(backup_path)}'")

    # Generate new CMakeLists.txt for Embedded Target
    content = """# Generated by env_doctor.py for NXP i.MX RT700
cmake_minimum_required(VERSION 3.13)
project(lvgl_guider C CXX ASM)

set(CMAKE_EXECUTABLE_SUFFIX ".elf")
set(CMAKE_C_STANDARD 99)
set(CMAKE_CXX_STANDARD 11)

# --------------------------------------------------------------------
# Source Discovery
# --------------------------------------------------------------------
file(GLOB_RECURSE SOURCES 
    "source/*.c" "source/*.cpp" "source/*.S"
    "board/*.c" "board/*.cpp"
    "custom/*.c" "custom/*.cpp"
    "generated/*.c" "generated/*.cpp"
    "sdk/*.c" "sdk/*.cpp" "sdk/*.S"
)

# Exclude Simulator & PC Port files
list(FILTER SOURCES EXCLUDE REGEX ".*lvgl-simulator.*")
list(FILTER SOURCES EXCLUDE REGEX ".*ports/linux.*")
list(FILTER SOURCES EXCLUDE REGEX ".*ports/windows.*")

# --------------------------------------------------------------------
# Include Directories
# --------------------------------------------------------------------
# Add all subdirectories in sdk, source, board, etc.
foreach(DIR source board custom generated sdk)
    if(IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/${DIR})
        file(GLOB_RECURSE CHILDREN LIST_DIRECTORIES true ${CMAKE_CURRENT_SOURCE_DIR}/${DIR}/*)
        foreach(CHILD ${CHILDREN})
            if(IS_DIRECTORY ${CHILD})
                include_directories(${CHILD})
            endif()
        endforeach()
        include_directories(${CMAKE_CURRENT_SOURCE_DIR}/${DIR})
    endif()
endforeach()

# --------------------------------------------------------------------
# Target Definition
# --------------------------------------------------------------------
add_executable(${PROJECT_NAME} ${SOURCES})

# Link standard embedded libraries
target_link_libraries(${PROJECT_NAME} PRIVATE m gcc c nosys)

message(STATUS "Configured for Embedded Target (Auto-Generated)")
"""
    
    try:
        with open(cmake_path, "w") as f:
            f.write(content)
        print_status("Replaced CMakeLists.txt with embedded target version.", True)
    except Exception as e:
        print_status(f"Failed to write CMakeLists.txt: {e}", False)

def check_cmake_consistency(target_main):
    print("\n[6] Checking CMakeLists.txt vs Target Main...")
    if not target_main:
        print("   -> No target main identified, skipping check.")
        return

    cmake_path = "CMakeLists.txt"
    if not os.path.exists(cmake_path):
        return

    try:
        with open(cmake_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        
        main_name = os.path.basename(target_main)
        
        # Check for Simulator indicators
        if "ports/linux/main.c" in content:
            print(f"‚ö†Ô∏è  MISMATCH: CMakeLists.txt targets PC Simulator.")
            print(f"   - It explicitly includes: 'ports/linux/main.c'")
            if main_name not in content:
                print(f"   - It MISSES:              '{main_name}' (Your Target Main)")
                print("   -> The build will likely FAIL for the embedded target.")
                
                # Check for common backups
                if os.path.exists("CMakeLists.txt.bak"):
                    print("   -> üí° Hint: Found 'CMakeLists.txt.bak'. Restoring...")
                    shutil.copy2("CMakeLists.txt.bak", "CMakeLists.txt")
                    print_status("Restored CMakeLists.txt from backup.", True)
                    return

                print("   -> Action: Generating correct CMakeLists.txt...")
                repair_cmake_mismatch(target_main)
                return

        print_status("CMakeLists.txt content looks plausible.", True)

    except Exception as e:
        print(f"   Error reading CMakeLists.txt: {e}")

def check_presets_alignment():
    print("\n[7] Checking CMake Presets Output Directory...")
    presets_path = "CMakePresets.json"
    if not os.path.exists(presets_path):
        print("   -> ‚ö†Ô∏è  CMakePresets.json not found.")
        return

    try:
        with open(presets_path, 'r') as f:
            data = json.load(f)
        
        updated = False
        for configure_preset in data.get("configurePresets", []):
            if configure_preset.get("name") == "flash_debug":
                current_dir = configure_preset.get("binaryDir", "")
                # We want it to be sdk/vscode/flash_debug to match user expectation
                target_dir = "${sourceDir}/sdk/vscode/flash_debug"
                
                if current_dir != target_dir:
                    print(f"   ‚ö†Ô∏è  Output directory mismatch in preset 'flash_debug'.")
                    print(f"      Current: {current_dir}")
                    print(f"      Target:  {target_dir} (Required for NXP extension)")
                    
                    configure_preset["binaryDir"] = target_dir
                    
                    # Also update cache variables if they use binaryDir
                    cache_vars = configure_preset.get("cacheVariables", {})
                    if "CMAKE_RUNTIME_OUTPUT_DIRECTORY" in cache_vars:
                        cache_vars["CMAKE_RUNTIME_OUTPUT_DIRECTORY"] = "${binaryDir}"
                    if "CMAKE_LIBRARY_OUTPUT_DIRECTORY" in cache_vars:
                        cache_vars["CMAKE_LIBRARY_OUTPUT_DIRECTORY"] = "${binaryDir}"
                    if "CMAKE_ARCHIVE_OUTPUT_DIRECTORY" in cache_vars:
                        cache_vars["CMAKE_ARCHIVE_OUTPUT_DIRECTORY"] = "${binaryDir}"
                        
                    updated = True

        if updated:
            with open(presets_path, 'w') as f:
                json.dump(data, f, indent=2)
            print_status("Fixed CMakePresets.json binaryDir to 'sdk/vscode/flash_debug'.", True)
        else:
            print_status("CMakePresets.json output directory is correct.", True)

    except Exception as e:
        print(f"   -> Error parsing CMakePresets.json: {e}")

def main():
    print("=== NXP i.MX RT700 Project Environment Doctor ===")
    
    if not check_structure():
        print("\n‚ö†Ô∏è  Missing directories detected. Repairing...")
        repair_structure()
        
    compiler = check_compiler()
    update_vscode_config(compiler)
    check_and_clean_cache()
    target_main = check_entry_point()
    check_cmake_consistency(target_main)
    check_presets_alignment()
    
    print("\n=== Environment Check Complete ===")

if __name__ == "__main__":
    main()